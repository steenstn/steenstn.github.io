<!DOCTYPE html>
<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title></title>
  <style>
    body {
      margin:0px;
      padding:0px;
      text-align:center;
      background-color: #000;
    }

    canvas{
      outline:0;
      border:1px solid #000;
	  image-rendering: optimizeSpeed;             /* Older versions of FF          */
	  image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
	  image-rendering: -webkit-optimize-contrast; /* Safari                        */
	  image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
	  image-rendering: pixelated;                 /* Awesome future-browsers       */
	  -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
	  transform:scale(1.5);
	  transform-origin: top;
      margin-left: auto;
      margin-right: auto;
	  margin-top:auto;
    }
  </style>
</head>
<body>

<script src="js/Player.js" type="text/javascript"></script>
<script src="js/Particle.js" type="text/javascript"></script>
<script src="js/Level.js" type="text/javascript"></script>
<script src="js/Viewport.js" type="text/javascript"></script>
<script src="js/enemyMovementStrategies/GlidingStrategy.js" language="javascript" type="text/javascript"></script>
<script src="js/enemyMovementStrategies/JumpingStrategy.js" language="javascript" type="text/javascript"></script>
<script src="js/enemyMovementStrategies/FlyingStrategy.js" language="javascript" type="text/javascript"></script>

<canvas id='c'></canvas>
<script>
var debug = 0;
var keyHeldDown = 0;
var numFramesSinceStart = 0;
var width = 800,
height = 500,
gLoop,
c = document.getElementById('c'),
ctx = c.getContext('2d');

c.width = width;
c.height = height;

var kickbackForce = 7;

var levelNow = 1; // Number of current level


var numTilesInScreenHeight = Math.round(height / Level.tileSize);
var numTilesInScreenWidth = Math.round(width / Level.tileSize);
var score = 0;
var dead=0;
var pickedArtefacts=0; // How many phadderists are collected?

var bloodAmount = 10;
var bloodImage = new Image();
bloodImage.src = "bloodpixel.png";
bloodImage.width=1;
bloodImage.height=1;

var image = new Image();
image.src = "playersprite.png";
image.width = 180;
image.height = 120;

var image2 = new Image();
image2.src = "playersprite2.png";
image2.width = 180;
image2.height = 120;
var players = [new Player(2*Level.tileSize, 2*Level.tileSize, image), new Player(2*Level.tileSize,2*Level.tileSize,image2)];


// A - 65
// D 68
// W 87
// S 83
// 38 up 37 left 39 right
players[0].keyLeft = 37
players[0].keyUp = 38
players[0].keyRight = 39
players[1].keyLeft = 65
players[1].keyRight = 68
players[1].keyUp = 87

var playerAcc=0.3;
var gravity=0.3;
var maxSpeedx=3; // Max speed for player
var maxSpeedy=6;
var normalFriction=1.2;
var friction=normalFriction;

var lastScore = 0;

var skurkImage = new Image();
skurkImage.src = "skurkerister.png";
skurkImage.width = 120;
skurkImage.height = 30;


var animationCounter = 0; // COunter for framerate of character
var animationSpeed = 5; // Number of ticks before changing frame
var currentFrame = 0; // The current frame of the character

var jumpStrength=7;
var jumpAcc=2;
var maxJump=7; // Maximum number of jumpsteps, the power of the jump
var currentLevel = new Array(Level.width*Level.height);

for(var i=0;i<currentLevel.length;i++)
	currentLevel[i]=new Object();

var enemies={};
var content = {};
var particles = [];

var tileset = new Image();
tileset.src = "tileset.png"; // Tileset for the level and all powerups
tileset.width=Level.tileSize;
tileset.height=Level.tileSize;


var init = function()
{
numFramesSinceStart = 0;

	screenx = 1;
	screeny = 1;

	var oldscreenx = screenx;
	var oldscreeny = screeny;

	particles = [];

  for(var i = 0; i < players.length; i++) {
    players[i].oldx = players[i].x;
  	players[i].oldy = players[i].y;

  	score=0;
  	players[i].hp=100;

  }

	pickedArtefacts=0;
}


var keysDown = {};

addEventListener("keydown", function (e) {
	keysDown[e.keyCode] = true;
}, false);

addEventListener("keyup", function (e) {
	delete keysDown[e.keyCode];

}, false);


var canvas = document.getElementById('c');


var clear = function(){
  ctx.fillStyle = '#d0e7f9';
  ctx.clearRect(0, 0, width, height);
  ctx.beginPath();
  ctx.rect(0, 0, width, height);
  ctx.closePath();
  ctx.fill();
}

var showRect = function(pos){
  var x = pos%Level.width;

  var y = Math.floor(pos/Level.width);
  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath();
  ctx.rect(x*Level.tileSize,y*Level.tileSize, Level.tileSize, Level.tileSize);
  ctx.closePath();
  ctx.fill();
}

// Function for checking for overlap between two rectangles
var overlap = function(x,y,width,height,x2,y2,width2,height2) {
	return (x < x2+width2 && x+width > x2 && y < y2+height2 && y+height > y2);
}


var render = function(){

	if(animationCounter>animationSpeed) {
		animationCounter=0;
		currentFrame=1-currentFrame;
	}

	for(var i = 0; i < players.length; i++) {
		if(players[i].speedy<-0.5) // JUmping up
		{
			ctx.drawImage(players[i].image,20,30*players[i].goingLeft, 20,30,Viewport.x+players[i].x,Viewport.y+players[i].y, players[i].width, players[i].height);
		}
		else if(players[i].speedy>0.5) // Jumping down
		{
			ctx.drawImage(players[i].image,40,30*players[i].goingLeft, 20,30,Viewport.x+players[i].x,Viewport.y+players[i].y, players[i].width, players[i].height);
		}
		else if(players[i].speedx>0.05 || players[i].speedx<-0.05) // Running
		{
			ctx.drawImage(players[i].image,60+20*currentFrame,30*players[i].goingLeft, 20,30,Viewport.x+players[i].x,Viewport.y+players[i].y, players[i].width, players[i].height);
		}
		else
			ctx.drawImage(players[i].image,0,30*players[i].goingLeft, 20,30,Viewport.x+players[i].x,Viewport.y+players[i].y, players[i].width, players[i].height);

    if(debug===1) {
      players[i].drawHurtZone(ctx);
      players[i].drawKillZone(ctx);
    }

	}
};

var renderEnemies = function()
{
	for(i=0;i<enemies.length;i++)
	{
		switch(enemies[i].type)
		{
			case "skurkerist":
				ctx.drawImage(skurkImage,5,0,18,30,Viewport.x+enemies[i].x,Viewport.y+enemies[i].y, 18, 30);
				break;
			case "jumper":
				ctx.drawImage(skurkImage,36,0,17,30,Viewport.x+enemies[i].x,Viewport.y+enemies[i].y, 17, 30);
				break;
			case "bouncer":
				ctx.drawImage(skurkImage,67,0,17,30,Viewport.x+enemies[i].x,Viewport.y+enemies[i].y, 17, 30);
				break;
			default:
			// Non-implemented enemy, if the enemy does nto have a type, a grey rectangle will be drawn
				ctx.fillStyle = '#111111';
				ctx.beginPath();
				ctx.rect(Viewport.x+enemies[i].x,Viewport.y+enemies[i].y,10,10);
				ctx.closePath();
				ctx.fill();
		}

	}
}


var updatePlayer = function(index) {
	players[index].oldx = players[index].x;
	players[index].oldy = players[index].y;

	players[index].x += players[index].speedx;

	// Check to the left if going left and stop the player if he collides with a blocking tile
	if(players[index].speedx < 0) {
		var arrayPos=Math.floor((players[index].x)/Level.tileSize)+Math.floor((players[index].y+players[index].height-2)/Level.tileSize)*Level.width; // The position in the level array(Middle of the player at the moment)
		//showRect(arrayPos);
		if(currentLevel[arrayPos].blocking==1) {
			players[index].x = players[index].oldx;
			players[index].speedx = 0;
		}
	} else {// Check to the right

		var arrayPos=Math.floor((players[index].x+players[index].width)/Level.tileSize)+Math.floor((players[index].y+players[index].height-2)/Level.tileSize)*Level.width; // The position in the level array(Middle of the player at the moment)


		if(typeof arrayPos !== 'NaN' && currentLevel[arrayPos].blocking==1) {
			players[index].x = players[index].oldx;
			players[index].speedx = 0;
		}
	}
	// Add gravity
	if(players[index].speedy < maxSpeedy) {
		players[index].speedy += gravity;
	}

	players[index].y += players[index].speedy;


	// If going up, check for blocking tiles
	if(players[index].speedy < 0) {
		arrayPos=Math.floor((players[index].x+players[index].width/2)/Level.tileSize)+Math.floor((players[index].y+5)/Level.tileSize)*Level.width;
		if(currentLevel[arrayPos].blocking==1) {
			players[index].y = players[index].oldy;
			players[index].speedy = 0;
		}
	} else if(players[index].speedy > 0) { // Going down, check for blocking tiles
		arrayPos=Math.floor((players[index].x+players[index].width/2)/Level.tileSize)+Math.floor((players[index].y+players[index].height)/(Level.tileSize))*Level.width;
		// If the player lands on a blocking tile, iteratively move him upwards until he is free from the
		// tile. This will remove bouncing when landing in high speed
		if(currentLevel[arrayPos].blocking==1) {
			players[index].jumping = 0;

			while(currentLevel[Math.floor((players[index].x+players[index].width/2)/Level.tileSize)+Math.floor((players[index].y+players[index].height)/Level.tileSize)*Level.width].blocking==1) {
				players[index].y-=0.2;
			}
			players[index].speedy=0;
		}
	}
	if(currentLevel[arrayPos].blocking==0) { // Disable jumping when in mid-air
		players[index].jumping++;
	}

	if(currentLevel[arrayPos].type=="g") // Ice block
		friction=1; // No friction
	else
		friction=normalFriction;

	// Move the screen when the players move
	var betweenPlayersX = (players[0].x+players[1].x) / 2;
	var betweenPlayersY = (players[0].y+players[1].y) / 2;

	Viewport.x=Math.round(-betweenPlayersX+(numTilesInScreenWidth / 2)*Level.tileSize);
	Viewport.y=Math.round(-betweenPlayersY+(numTilesInScreenHeight / 2)*Level.tileSize);



	// Do not move the screen outside of the level
	if(Viewport.x>0)
		Viewport.x=0;
	if(Viewport.x<-Level.width*Level.tileSize+numTilesInScreenWidth*Level.tileSize)
		Viewport.x=-Level.width*Level.tileSize+numTilesInScreenWidth*Level.tileSize;

	if(Viewport.y>0)
		Viewport.y=0;
	if(Viewport.y<-Level.height*Level.tileSize+numTilesInScreenHeight*Level.tileSize)
		Viewport.y=-Level.height*Level.tileSize+numTilesInScreenHeight*Level.tileSize


	players[index].updateKillZone();
	players[index].updateHurtZone();

	arrayPos=Math.floor((players[index].x+players[index].width/2)/Level.tileSize)+Math.floor((players[index].y+players[index].height)/Level.tileSize)*Level.width;

	if(currentLevel[arrayPos].type=="p" || currentLevel[arrayPos].type=="q") // 3Cant + Tryckbar, health
	{
		if(players[index].hp<100)
			players[index].hp+=10;
		if(players[index].hp>100)
			players[index].hp=100;
		currentLevel[arrayPos].type=".";
	}
	if(currentLevel[arrayPos].type=="s") // Coins
	{
		score+=20;
		currentLevel[arrayPos].type=".";
	}
	if(currentLevel[arrayPos].type=="l" || currentLevel[arrayPos].type=="m" || currentLevel[arrayPos].type=="n" || currentLevel[arrayPos].type=="o") // Phadderist
	{
		pickedArtefacts++;
		score+=50;
		currentLevel[arrayPos].type=".";
	}

}


var updateEnemies = function() {

	for(i=0;i<enemies.length;i++) {
		enemies[i].oldx=enemies[i].x;
		enemies[i].oldy=enemies[i].y;
    var enemyIsInteracting = false;
    var enemyIsDead = false;
    for(var playerIndex = 0; playerIndex < players.length; playerIndex++) {

      var enemyInHurtZone = overlap(enemies[i].x,enemies[i].y,20,20,players[playerIndex].hurtZonex,players[playerIndex].hurtZoney,players[playerIndex].hurtZoneWidth,players[playerIndex].hurtZoneHeight);
      var enemyInKillZone = overlap(enemies[i].x,enemies[i].y,20,20,players[playerIndex].killZonex,players[playerIndex].killZoney,players[playerIndex].killZoneWidth,players[playerIndex].killZoneHeight);

  		if(enemyInHurtZone) { // 1 = right
        if(enemies[i].direction==1) {
          players[playerIndex].speedx=kickbackForce;
          for(var bloodIndex = 0; bloodIndex < bloodAmount; bloodIndex++) {
            particles.push(new Particle(players[playerIndex].x, players[playerIndex].y+Math.random()*25, kickbackForce*3*Math.random(), -3*Math.random(), bloodImage));
          }
        }
        else{
  			     players[playerIndex].speedx=-1*kickbackForce;
             for(var bloodIndex = 0; bloodIndex < bloodAmount; bloodIndex++) {
             particles.push(new Particle(players[playerIndex].x, players[playerIndex].y+Math.random()*25, -1*kickbackForce*3*Math.random(), -3*Math.random(), bloodImage));
           }
        }
        players[playerIndex].speedy=-0.25*kickbackForce;
  			players[playerIndex].hp-=2;
        enemyIsInteracting = true;
  		} else if(enemyInKillZone) {
  			enemies.splice(i,1); // Remove the enemy from the array
  			players[playerIndex].speedy=-4;
  			score+=100;
        enemyIsDead = true;
        break;
  		}
    }
    if(!enemyIsDead && !enemyIsInteracting) {
      enemies[i].strategy.move();
    }
	}
}

var updateParticles = function() {
  for(var i = 0; i < particles.length; i++) {
    var arrayPos = Math.floor((particles[i].x)/Level.tileSize)+Math.floor((particles[i].y)/Level.tileSize)*Level.width;
    var downRight = Math.floor((particles[i].x+1)/Level.tileSize)+Math.floor((particles[i].y+1)/Level.tileSize)*Level.width;
    var downLeft = Math.floor((particles[i].x-1)/Level.tileSize)+Math.floor((particles[i].y+1)/Level.tileSize)*Level.width;
    var down = Math.floor((particles[i].x)/Level.tileSize)+Math.floor((particles[i].y+1)/Level.tileSize)*Level.width;


    var isDownLeftBlocked = currentLevel[downLeft].blocking==1;
    var isDownRightBlocked = currentLevel[downRight].blocking==1;
    var isDownBlocked = currentLevel[down].blocking==1;

    if(isDownBlocked && isDownRightBlocked && isDownLeftBlocked) {
      particles[i].state = 0;
    } else if(isDownBlocked && (!isDownRightBlocked || !isDownLeftBlocked)) {
      particles[i].state = 2;
    } else {
      particles[i].state = 1;
    }

    particles[i].move();
  }
}

var checkKeys = function (modifier) {

  if(79 in keysDown) { // o
    keyHeldDown++;
    if(keyHeldDown === 1) {
      debug = 1 - debug;
    }
  } else {
    keyHeldDown = 0;
  }
	for(var i = 0; i < players.length; i++) {

		if (players[i].keyUp in keysDown) {
			if(players[i].jumping < maxJump) {
				players[i].jumping++;

				if(players[i].speedy>-jumpStrength)
				    players[i].speedy-=jumpAcc;
			}
		}

		if (players[i].keyLeft in keysDown) {
		players[i].goingLeft = 1;
		animationCounter++;
			if(players[i].speedx>-maxSpeedx)
				players[i].speedx -= playerAcc * modifier;
		}
		else if (players[i].keyRight in keysDown) {
		players[i].goingLeft = 0;
		animationCounter++;
			if(players[i].speedx<maxSpeedx)
				players[i].speedx += playerAcc * modifier;
		}
		else
			players[i].speedx/=friction; // Decelerate
      if(Math.abs(players[i].speedx) < 0.05) {
        players[i].x = Math.round(players[i].x);
      }
		}

}

var loadContent = function(levelName) {
	//enemies.length = 0; // Reset the enemy array
	var xobj = new XMLHttpRequest();
    xobj.overrideMimeType("application/json");
    xobj.open('GET', "levels/" + levelName+'enemies.json', false);

	xobj.send(null);
	var jsonTexto = xobj.responseText;
	enemies = JSON.parse(jsonTexto);
  for(var i = 0; i < enemies.length; i++) {
    switch(enemies[i].type) {
      case "skurkerist": // Flies back and forth, no gravity
          enemies[i].strategy = new GlidingStrategy(enemies[i], currentLevel)
        break;
      case "jumper": // Runs around, jumps when it discovers an edge
        enemies[i].strategy = new JumpingStrategy(enemies[i], currentLevel, maxSpeedy, gravity);
        break;
      case "bouncer": // Flies around and bounces on the walls
        enemies[i].strategy = new FlyingStrategy(enemies[i], currentLevel);
        break;
    }

  }

	xobj = new XMLHttpRequest();
    xobj.overrideMimeType("application/json");
    xobj.open('GET', "levels/" + levelName+'content.json', false);

	xobj.send(null);
	jsonTexto = xobj.responseText;
	content = JSON.parse(jsonTexto);
}

var loadLevel = function(levelNumber) {
var levelName = "level"+levelNumber;
 currentLevel = new Array(Level.width*Level.height);

for(var i=0;i<currentLevel.length;i++) { // set up an object for all tiles
	currentLevel[i]=new Object();
}
var txtFile = new XMLHttpRequest();

txtFile.open("GET", "levels/" + levelName + ".txt", true);
txtFile.onreadystatechange = function() {
  if (txtFile.readyState === 4) {  // Makes sure the document is ready to parse.
    if (txtFile.status === 200 || txtFile.status == 0) {  // Makes sure it's found the file.
      allText = txtFile.responseText;
	  allText = allText.replace(/(\r\n|\n|\r)/gm,"");
     // lines = txtFile.responseText.split("\n"); // Will separate each line into an array

		for(var y=0;y<Level.height;y++) {
			for(var x=0;x<Level.width;x++) {
				var arrayPos = x+y*Level.width;
				currentLevel[arrayPos].type=allText[arrayPos]; // What kind of block is it?
				switch(currentLevel[arrayPos].type) {
					case ".": // Empty tile
						currentLevel[arrayPos].blocking=0;
						break;
					case "1": // Ground tile
						currentLevel[arrayPos].blocking=1; // Blocking tile
						currentLevel[arrayPos].tileOffsetx=0; // Where in the tileset the tile is
						currentLevel[arrayPos].tileOffsety=0;
						break;
					case "2": // Ground tile
						currentLevel[arrayPos].blocking=1; // Blocking tile
						currentLevel[arrayPos].tileOffsetx=32;
						currentLevel[arrayPos].tileOffsety=0;
						break;
					case "3": // Ground tile
						currentLevel[arrayPos].blocking=1; // Blocking tile
						currentLevel[arrayPos].tileOffsetx=64;
						currentLevel[arrayPos].tileOffsety=0;
						break;
					case "4": // Ground tile
						currentLevel[arrayPos].blocking=1; // Blocking tile
						currentLevel[arrayPos].tileOffsetx=96;
						currentLevel[arrayPos].tileOffsety=0;
						break;
					case "5": // Ground tile
						currentLevel[arrayPos].blocking=1; // Blocking tile
						currentLevel[arrayPos].tileOffsetx=0;
						currentLevel[arrayPos].tileOffsety=32;
						break;
					case "6": // Ground tile
						currentLevel[arrayPos].blocking=1; // Blocking tile
						currentLevel[arrayPos].tileOffsetx=32;
						currentLevel[arrayPos].tileOffsety=32;
						break;
					case "7": // Ground tile
						currentLevel[arrayPos].blocking=1; // Blocking tile
						currentLevel[arrayPos].tileOffsetx=64;
						currentLevel[arrayPos].tileOffsety=32;
						break;
					case "8": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=96;
						currentLevel[arrayPos].tileOffsety=32;
						break;
					case "9": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=0;
						currentLevel[arrayPos].tileOffsety=64;
						break;
					case "0": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=32;
						currentLevel[arrayPos].tileOffsety=64;
						break;
					case "a": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=64;
						currentLevel[arrayPos].tileOffsety=64;
						break;
					case "b": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=96;
						currentLevel[arrayPos].tileOffsety=64;
						break;
					case "c": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=0;
						currentLevel[arrayPos].tileOffsety=96;
						break;
					case "d": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=32;
						currentLevel[arrayPos].tileOffsety=96;
						break;
					case "e": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=64;
						currentLevel[arrayPos].tileOffsety=96;
						break;
					case "f": // Ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=96;
						currentLevel[arrayPos].tileOffsety=96;
						break;
					case "g": // Ice ground tile
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=0;
						currentLevel[arrayPos].tileOffsety=128;
						break;
					case "h": // Tree
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=32;
						currentLevel[arrayPos].tileOffsety=128;
						break;
					case "i":
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=64;
						currentLevel[arrayPos].tileOffsety=128;
						break;
					case "j":
						currentLevel[arrayPos].blocking=1;
						currentLevel[arrayPos].tileOffsetx=96;
						currentLevel[arrayPos].tileOffsety=128;
						break;
					case "k":
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=0;
						currentLevel[arrayPos].tileOffsety=160;
						break;
					case "l":
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=96;
						currentLevel[arrayPos].tileOffsety=160;
						break;
					case "m":
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=32;
						currentLevel[arrayPos].tileOffsety=192;
						break;
					case "n":
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=64;
						currentLevel[arrayPos].tileOffsety=192;
						break;
					case "o":
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=0;
						currentLevel[arrayPos].tileOffsety=192;
						break;
					case "p": // 3Cant
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=96;
						currentLevel[arrayPos].tileOffsety=224;
						break;
					case "q": // Tryckbar
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=64;
						currentLevel[arrayPos].tileOffsety=224;
						break;
					case "s": // Cash
						currentLevel[arrayPos].blocking=0;
						currentLevel[arrayPos].tileOffsetx=64;
						currentLevel[arrayPos].tileOffsety=128;
						break;
				}
			}
		}

    }

  }
}
txtFile.send(null);

loadContent(levelName);
setUpContent();
}

var setUpContent = function() {

	for(var i = 0; i < content.length; i++) {
		switch(content[i].type) {
			case "startPos":
        var offset = 10;
				players[0].x = content[i].x - offset;
        players[1].x = content[i].x + offset;
				players[0].y = players[1].y = content[i].y;
			break;
		}
	}
}


var drawLevel = function() {
	//Only loop through tiles that are almost in the screen
	var startx=Math.floor(-Viewport.x/Level.tileSize)-1;
	var starty=Math.floor(-Viewport.y/Level.tileSize)-1;
	if(startx<0)
		startx=0;
	if(starty<0)
		starty=0;
	var endx=startx+width/Level.tileSize+2;
	var endy=starty+height/Level.tileSize+2;



	if(endx>Level.width)
		endx=Level.width;
	if(endy>Level.height)
		endy=Level.height;


	for(var y=starty;y<endy;y++) {
		for(var x=startx;x<endx;x++) {
			var posx = Math.round(Viewport.x+x*Level.tileSize);
			var posy = Math.round(Viewport.y+y*Level.tileSize);

      var isAirTile = currentLevel[x+y*Level.width].type==="."
			if(!isAirTile) {
				ctx.drawImage(tileset,currentLevel[x+y*Level.width].tileOffsetx,currentLevel[x+y*Level.width].tileOffsety, Level.tileSize,
					Level.tileSize,posx,posy, Level.tileSize, Level.tileSize);
			}

		}
	}

  for(var i = 0; i < particles.length; i++) {
    particles[i].render(ctx, Viewport.x, Viewport.y);
  }
}
var drawText = function() {
	ctx.fillStyle    = '#F00';
    ctx.font         = '10px Verdana';
    ctx.textBaseline = 'Top';
    ctx.fillText  ("Score: " + score, 4,20);

    if(debug===1) {
      ctx.fillText  ("particles: " + particles.length, 4,60);
      ctx.fillText  ("numFramesSinceStart: " + numFramesSinceStart, 4,75);

    }
	ctx.strokeStyle = "black";
	ctx.strokeRect(4,30,102,10);
	if(players[0].dead==0) {
		ctx.fillStyle = "rgb(50,129,28)";
		ctx.fillRect (5,31,players[0].hp,8);
	}

}

var GameLoop = function(){
  numFramesSinceStart++;
	clear();
	if(players[0].hp<1) {
		players[0].hp=0;
		score=lastScore;
		loadLevel(levelNow);

		init();
	}
	if(players[0].dead==0) {
		checkKeys(1);

		updatePlayer(0);
		updatePlayer(1);
		render();
	}

	updateEnemies();
  updateParticles();
  renderEnemies();
	drawLevel();
	arrayPos=Math.floor((players[0].x+players[0].width/2)/Level.tileSize)+Math.floor((players[0].y+players[0].height)/Level.tileSize)*Level.width;

	if(currentLevel[arrayPos].type=="k") {
		if(pickedArtefacts>3) {
			levelNow++;
			lastScore=score;
			loadLevel(levelNow);

			init();
		} else {
			ctx.fillStyle    = '#F00';
			ctx.font         = '16px Sans-Serif';
			ctx.textBaseline = 'Top';
			ctx.fillText  ("Find all the beardy heads...", 100,100);
		}
	}
	drawText();
	gLoop = setTimeout(GameLoop, 1000 / 50);
}

init();
loadLevel(levelNow);
GameLoop();

</script>



</body>
</html>
