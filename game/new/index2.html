<!DOCTYPE html>
<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title></title>
  <style>
    body {
      margin:0px;
      padding:0px;
      text-align:center;
      background-color: #000;
    }

    canvas{
      outline:0;
      border:1px solid #666;
	  image-rendering: optimizeSpeed;             /* Older versions of FF          */
	  image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
	  image-rendering: -webkit-optimize-contrast; /* Safari                        */
	  image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
	  image-rendering: pixelated;                 /* Awesome future-browsers       */
	  -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
	  transform:scale(2);
	  transform-origin: top;
      margin-left: auto;
      margin-right: auto;
	  margin-top:40px;
    }
  </style>
</head>
<body>

<script src="js/Level.js" type="text/javascript"></script>
<script src="js/LevelTile.js" type="text/javascript"></script>
<script src="js/Viewport.js" type="text/javascript"></script>
<script src="js/Player.js" type="text/javascript"></script>
<script src="js/Jukebox.js" type="text/javascript"></script>
<script src="js/Background.js" type="text/javascript"></script>
<script src="js/WorldConstants.js" type="text/javascript"></script>
<script src="js/particles/Particle.js" type="text/javascript"></script>
<script src="js/particles/BloodParticle.js" type="text/javascript"></script>
<script src="js/particles/TimedParticle.js" type="text/javascript"></script>
<script src="js/particles/HealthParticle.js" type="text/javascript"></script>
<script src="js/particles/BloodFactory.js" type="text/javascript"></script>
<script src="js/particles/TimedParticleFactory.js" type="text/javascript"></script>
<script src="js/particles/HealthParticleFactory.js" type="text/javascript"></script>

<script src="js/Helper.js" type="text/javascript"></script>

<script src="js/particles/ParticleCleaner.js" type="text/javascript"></script>

<script src="js/enemies/Enemy.js" type="text/javascript"></script>
<script src="js/enemies/Mutant.js" type="text/javascript"></script>
<script src="js/enemies/Bouncer.js" type="text/javascript"></script>
<script src="js/enemies/Skull.js" type="text/javascript"></script>
<script src="js/enemies/Jumper.js" type="text/javascript"></script>

<script src="js/enemyMovementStrategies/GlidingStrategy.js" language="javascript" type="text/javascript"></script>
<script src="js/enemyMovementStrategies/JumpingStrategy.js" language="javascript" type="text/javascript"></script>
<script src="js/enemyMovementStrategies/FlyingStrategy.js" language="javascript" type="text/javascript"></script>
<script src="js/enemyMovementStrategies/MutantStrategy.js" language="javascript" type="text/javascript"></script>

<canvas id='c'></canvas>
<script>

var debug = 0;
var pixelBackground = 0;
var keyHeldDown = 0;
var numFramesSinceStart = 0;

var gLoop,
c = document.getElementById('c'),
ctx = c.getContext('2d');

c.width = Viewport.width;
c.height = Viewport.height;

var levelNow = 1; // Number of current level
var score = 0;
var dead=0;
var bloodImage = new Image();
bloodImage.src = "particles/bloodpixel.png";
bloodImage.width=1;
bloodImage.height=1;

var coinParticleImage=new Image();
coinParticleImage.src = "particles/coinpixel.png";
coinParticleImage.width=2;
coinParticleImage.height=2;

var whiteParticleImage = new Image();
whiteParticleImage.src = "particles/whitepixel.png";

var blackParticleImage = new Image();
blackParticleImage.src = "particles/blackpixel.png";

var blackParticleFactory = new HealthParticleFactory(blackParticleImage);
var whiteParticleFactory = new HealthParticleFactory(whiteParticleImage);

var coinParticleFactory = new TimedParticleFactory(coinParticleImage);

var logoImage = new Image();
logoImage.src = "logo2.png";

var jukeBox = new Jukebox(["roulette_dares.mp3","teflon.mp3", "vermicide.mp3", "televators.mp3"]);
var bloodFactory = new BloodFactory(bloodImage);

var particleCleaner = new ParticleCleaner();

var image = new Image();
image.src = "playersprite.png";
image.width = 180;
image.height = 120;

var image2 = new Image();
image2.src = "playersprite2.png";
image2.width = 180;
image2.height = 120;
var players = [new Player(2*Level.tileSize, 2*Level.tileSize, image), new Player(2*Level.tileSize,2*Level.tileSize,image2)];

var playerIsOutOfBounds = false;
var outOfBoundsTimer = 0;
// A - 65
// D 68
// W 87
// S 83
// 38 up 37 left 39 right
players[0].keyLeft = 37
players[0].keyUp = 38
players[0].keyRight = 39
players[1].keyLeft = 65
players[1].keyRight = 68
players[1].keyUp = 87

var friction=WorldConstants.normalFriction;

var lastScore = 0;

var skurkImage = new Image();
skurkImage.src = "skurkerister.png";
skurkImage.width = 120;
skurkImage.height = 30;

Bouncer.image = skurkImage;

var backgroundImage = new Image();
backgroundImage.src = "background.png";

var background = new Background(ctx);
Skull.image.src = "skull.png";
Skull.image.width = 40;
Skull.image.height = 50;

Mutant.image.src = "mutant.png";
Mutant.image.width = 88;
Mutant.image.height = 36;

Jumper.image.src = "frances.png";
Jumper.image.width = 32;
Jumper.image.height = 60;

var mutantSpecs;

var animationSpeed = 3; // Number of ticks before changing frame

for(var i=0;i<Level.currentLevel.length;i++)
	Level.currentLevel[i]=new Object();

var enemies={};
var content = {};
var particles = [];

var tileset = new Image();
tileset.src = "tileset.png"; // Tileset for the level and all powerups
tileset.width=Level.tileSize;
tileset.height=Level.tileSize;


var init = function() {
  numFramesSinceStart = 0;

	particles = [];

  for(var i = 0; i < players.length; i++) {
    players[i].oldx = players[i].x;
  	players[i].oldy = players[i].y;

  	score=0;
  	players[i].hp=100;

  }
}


var keysDown = {};

addEventListener("keydown", function (e) {
	keysDown[e.keyCode] = true;
}, false);

addEventListener("keyup", function (e) {
	delete keysDown[e.keyCode];

}, false);


var canvas = document.getElementById('c');


var clear = function(){
  if(pixelBackground) {
  ctx.drawImage(backgroundImage,0,0);

  } else {
    background.drawBackground();
  }
}

var clearBlack = function() {
  ctx.fillStyle = '#000';
  ctx.clearRect(0, 0, Viewport.width, Viewport.height);
  ctx.beginPath();
  ctx.rect(0, 0, Viewport.width, Viewport.height);
  ctx.closePath();
  ctx.fill();
}

var showRect = function(pos){
  var x = pos%Level.width;

  var y = Math.floor(pos/Level.width);
  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath();
  ctx.rect(x*Level.tileSize,y*Level.tileSize, Level.tileSize, Level.tileSize);
  ctx.closePath();
  ctx.fill();
}

var render = function(){
	for(var i = 0; i < players.length; i++) {
    players[i].draw(ctx);
    if(debug===1) {
      players[i].drawHurtZone(ctx);
      players[i].drawKillZone(ctx);
    }

	}
};

var renderEnemies = function()
{
	for(i=0;i<enemies.length;i++)
	{
    var enemyWidth = typeof enemies[i].width == 'number' ? enemies[i].width : 20;
    var enemyHeight = typeof enemies[i].height == 'number' ? enemies[i].height : 20;
    if(debug == 1) {
      ctx.fillStyle = '#FF0a00';
      ctx.beginPath();
      ctx.rect(enemies[i].x + Viewport.x, enemies[i].y + Viewport.y,enemyWidth, enemyHeight);
      ctx.closePath();
      ctx.fill();
    }
    enemies[i].draw(ctx);
	}
}


var updatePlayer = function(index) {

  if(index === 0) { // Collision between players
    var distX = players[0].x+players[0].width/2 - (players[1].x+players[1].width/2);
    var distY = players[0].y+players[0].height/2 - (players[1].y+players[1].height/2);

    var squareDist = distX*distX + distY*distY;
    if(squareDist <= (players[0].width/2 + players[1].width/2) * (players[0].width/2 + players[1].width/2)){
      players[0].x = players[0].oldx;
      players[0].y = players[0].oldy;

      players[1].x = players[1].oldx;
      players[1].y = players[1].oldy;

      var xSpeed = players[0].speedx;
      var ySpeed = players[0].speedy;
      players[0].speedx = players[1].speedx;
      players[0].speedy = players[1].speedy != 0 ? players[1].speedy : -players[0].speedy;

      players[1].speedx = xSpeed;
      players[1].speedy = ySpeed != 0 ? ySpeed : -players[1].speedy;

    }
  }

	players[index].oldx = players[index].x;
	players[index].oldy = players[index].y;


  if(players[index].x + Viewport.x < -1*players[index].width+5) {
    players[index].speedx = WorldConstants.kickbackForce;
    playerIsOutOfBounds = true;
    outOfBoundsTimer = 100;
  }
  if(players[index].x + Viewport.x > Viewport.width -5) {
    players[index].speedx = -1*WorldConstants.kickbackForce;
    playerIsOutOfBounds = true;
    outOfBoundsTimer = 100;
  }
  if(players[index].y + Viewport.y > Viewport.height - players[index].height+10) {
    players[index].speedy = -1*WorldConstants.kickbackForce;
    playerIsOutOfBounds = true;
    outOfBoundsTimer = 100;
  }
	players[index].x += players[index].speedx;




	// Check to the left if going left and stop the player if he collides with a blocking tile
	if(players[index].speedx < 0) {
		var arrayPos=Level.getBlockAt(players[index].x, players[index].y + players[index].height-2);

		if(arrayPos.blocking==1) {
			players[index].x = players[index].oldx;
			players[index].speedx = 0;
		}
	} else {// Check to the right

		var arrayPos=Level.getBlockAt(players[index].x + players[index].width, players[index].y + players[index].height-2);


		if(typeof arrayPos !== 'NaN' && arrayPos.blocking==1) {
			players[index].x = players[index].oldx;
			players[index].speedx = 0;
		}
	}
	// Add gravity
	if(players[index].speedy < WorldConstants.maxSpeedy) {
		players[index].speedy += WorldConstants.gravity;
	}

	players[index].y += players[index].speedy;


	// If going up, check for blocking tiles
	if(players[index].speedy < 0) {
		arrayPos=Math.floor((players[index].x+players[index].width/2)/Level.tileSize)+Math.floor((players[index].y+5)/Level.tileSize)*Level.width;
		if(typeof Level.currentLevel[arrayPos] != "undefined" && Level.currentLevel[arrayPos].blocking==1) {
			players[index].y = players[index].oldy;
			players[index].speedy = 0;
		}
	} else if(players[index].speedy > 0) { // Going down, check for blocking tiles
		arrayPos=Math.floor((players[index].x+players[index].width/2)/Level.tileSize)+Math.floor((players[index].y+players[index].height)/(Level.tileSize))*Level.width;
		// If the player lands on a blocking tile, iteratively move him upwards until he is free from the
		// tile. This will remove bouncing when landing in high speed
		if(typeof Level.currentLevel[arrayPos] != "undefined" && Level.currentLevel[arrayPos].blocking==1) {
			players[index].jumping = 0;

			while(Level.getBlockAt(players[index].x+players[index].width/2, players[index].y+players[index].height).blocking==1) {
				players[index].y-=0.2;
			}
			players[index].speedy=0;
		}
	}
	if(typeof Level.currentLevel[arrayPos] != "undefined" && Level.currentLevel[arrayPos].blocking==0) { // Disable jumping when in mid-air
		players[index].jumping++;
	}

	if(typeof Level.currentLevel[arrayPos] != "undefined" && Level.currentLevel[arrayPos].type=="g") // Ice block
		friction=1; // No friction
	else
		friction=WorldConstants.normalFriction;

  Viewport.moveToCenter(players[0].x, players[0].y, players[1].x, players[1].y);


	players[index].updateKillZone();
	players[index].updateHurtZone();

	arrayPos=Math.floor((players[index].x+players[index].width/2)/Level.tileSize)+Math.floor((players[index].y+players[index].height)/Level.tileSize)*Level.width;

	if(Level.currentLevel[arrayPos].type=="p" || Level.currentLevel[arrayPos].type=="q") // 3Cant + Tryckbar, health
	{

		Level.currentLevel[arrayPos].type=".";
    for(let i = 0; i < 30; i++) {
      particles.push(whiteParticleFactory.createParticle(players[index].x, players[index].y,players[1-index]));
      particles.push(blackParticleFactory.createParticle(players[index].x, players[index].y,players[1-index]));
      particles.push(whiteParticleFactory.createParticle(players[index].x, players[index].y,players[index]));
      particles.push(blackParticleFactory.createParticle(players[index].x, players[index].y,players[index]));
    }
	}
	if(Level.currentLevel[arrayPos].type=="s") // Coins
	{
		score+=20;
		Level.currentLevel[arrayPos].type=".";
    for(let i = 0; i < 20; i++) {
      particles.push(coinParticleFactory.createParticle(players[index].x, players[index].y,100));
    }
	}
	if(Level.currentLevel[arrayPos].type=="l" || Level.currentLevel[arrayPos].type=="m" || Level.currentLevel[arrayPos].type=="n" || Level.currentLevel[arrayPos].type=="o") // Phadderist
	{
		score+=50;
		Level.currentLevel[arrayPos].type=".";
	}

}

var updateEnemies = function() {

	for(i=0;i<enemies.length;i++) {
		enemies[i].oldx=enemies[i].x;
		enemies[i].oldy=enemies[i].y;
    var enemyIsInteracting = false;
    var enemyIsDead = false;
    for(var playerIndex = 0; playerIndex < players.length; playerIndex++) {

      var enemyWidth = typeof enemies[i].width == 'number' ? enemies[i].width : 20;
      var enemyHeight = typeof enemies[i].height == 'number' ? enemies[i].height : 20;

      var enemyInHurtZone = Helper.overlap(enemies[i].x,enemies[i].y,enemyWidth,enemyHeight,players[playerIndex].hurtZonex,players[playerIndex].hurtZoney,players[playerIndex].hurtZoneWidth,players[playerIndex].hurtZoneHeight);
      var enemyInKillZone = Helper.overlap(enemies[i].x,enemies[i].y,enemyWidth,enemyHeight,players[playerIndex].killZonex,players[playerIndex].killZoney,players[playerIndex].killZoneWidth,players[playerIndex].killZoneHeight);

  		if(enemyInHurtZone) { // 1 = right
        if(enemies[i].speedx>0) {
          players[playerIndex].speedx=WorldConstants.kickbackForce;
          for(var bloodIndex = 0; bloodIndex < WorldConstants.bloodAmount; bloodIndex++) {
            particles.push(bloodFactory.createBlood(players[playerIndex].x, players[playerIndex].y, 1));
          }
        }
        else{
  			     players[playerIndex].speedx=-1*WorldConstants.kickbackForce;
             for(var bloodIndex = 0; bloodIndex < WorldConstants.bloodAmount; bloodIndex++) {
             particles.push(bloodFactory.createBlood(players[playerIndex].x, players[playerIndex].y, -1));
           }
        }
        players[playerIndex].speedy=-0.25*WorldConstants.kickbackForce;
  			players[0].hp-=2;
        enemyIsInteracting = true;
  		} else if(enemyInKillZone) {
        for(var bloodIndex = 0; bloodIndex < WorldConstants.bloodAmount; bloodIndex++) {
          particles.push(bloodFactory.createBlood(enemies[i].x, enemies[i].y, 1));
          particles.push(bloodFactory.createBlood(enemies[i].x, enemies[i].y, -1));
        }
  			enemies.splice(i,1); // Remove the enemy from the array


  			players[playerIndex].speedy=-4;
  			score+=100;
        enemyIsDead = true;
        break;
  		}
    }
    if(!enemyIsDead && !enemyIsInteracting) {
        enemies[i].move();
    }
	}
}

var updateParticles = function() {
  for(var i = 0; i < particles.length; i++) {
    particles[i].move();
  }
}

var checkKeys = function (modifier) {

  if(79 in keysDown) { // o
    keyHeldDown++;
    if(keyHeldDown === 1) {
      debug = 1 - debug;
    }
  } else if(71 in keysDown) { // g
    keyHeldDown++;
    if(keyHeldDown === 1) {
      pixelBackground = 1 - pixelBackground;
    }
  } else {
    keyHeldDown = 0;
  }
	for(var i = 0; i < players.length; i++) {

		if (players[i].keyUp in keysDown) {
			if(players[i].jumping < WorldConstants.maxJump) {
				players[i].jumping++;

				if(players[i].speedy>-WorldConstants.jumpStrength)
				    players[i].speedy-=WorldConstants.jumpAcc;
			}
		}

		if (players[i].keyLeft in keysDown) {
		players[i].goingLeft = 1;
		players[i].animationCounter++;
			if(players[i].speedx>-WorldConstants.maxSpeedx)
				players[i].speedx -= WorldConstants.playerAcc * modifier;
		}
		else if (players[i].keyRight in keysDown) {
		players[i].goingLeft = 0;
		players[i].animationCounter++;
			if(players[i].speedx<WorldConstants.maxSpeedx)
				players[i].speedx += WorldConstants.playerAcc * modifier;
		}
		else
			players[i].speedx/=friction; // Decelerate
      if(Math.abs(players[i].speedx) < 0.05) {
        players[i].x = Math.round(players[i].x);
        players[i].idleAnimationCounter++;
      }
		}

}


var loadJsonFile = function(path) {
  var xobj = new XMLHttpRequest();
  xobj.overrideMimeType("application/json");
  xobj.open('GET', path, false);
  xobj.send(null);
  var jsonTexto = xobj.responseText;
  return JSON.parse(jsonTexto);
}

var loadContent = function(levelName) {

	enemies = loadJsonFile("levels/" + levelName+'enemies.json');
  for(var i = 0; i < enemies.length; i++) {
    switch(enemies[i].type) {
      case "skull":
      case "skurkerist": // Flies back and forth, no gravity
          enemies[i]= new Skull(enemies[i], Level.currentLevel)
        break;
      case "mutant":
        enemies[i] = new Mutant(enemies[i], Level.currentLevel);
        break;
      case "jumper": // Runs around, jumps when it discovers an edge
        enemies[i] = new Jumper(enemies[i], Level.currentLevel);
        break;
      case "bouncer": // Flies around and bounces on the walls
        enemies[i] = new Bouncer(enemies[i], Level.currentLevel);
        break;
    }
  }
	content = loadJsonFile("levels/" + levelName+'content.json');//JSON.parse(jsonTexto);
}

var loadLevel = function(levelNumber) {

  clearBlack();

var levelName = "level"+levelNumber;
 Level.currentLevel = new Array(Level.width*Level.height);

for(var i=0;i<Level.currentLevel.length;i++) { // set up an object for all tiles
	Level.currentLevel[i]=new Object();
}
var txtFile = new XMLHttpRequest();
drawText("Loading song...", 10,10);
jukeBox.selectSong(levelNow);

drawText("Loading level...", 10, 20);
txtFile.open("GET", "levels/" + levelName + ".txt", true);
txtFile.onreadystatechange = function() {
  if (txtFile.readyState === 4) {  // Makes sure the document is ready to parse.
    if (txtFile.status === 200 || txtFile.status == 0) {  // Makes sure it's found the file.
      allText = txtFile.responseText;
	  allText = allText.replace(/(\r\n|\n|\r)/gm,"");
     // lines = txtFile.responseText.split("\n"); // Will separate each line into an array
     drawText("Parsing level...", 10,30);

    var loadingBarMaxWidth = 600;

		for(var y=0;y<Level.height;y++) {
      var progress = (y/Level.height) * loadingBarMaxWidth;
      ctx.beginPath();

      ctx.rect(30, 30, progress, 2);
      ctx.closePath();
      ctx.fill();

			for(var x=0;x<Level.width;x++) {
				var arrayPos = x+y*Level.width;
				Level.currentLevel[arrayPos].type=allText[arrayPos]; // What kind of block is it?
        var tile = LevelTile.newFromCharacter(Level.currentLevel[arrayPos].type);
        Level.currentLevel[arrayPos].blocking=tile.blocking; // Blocking tile
        Level.currentLevel[arrayPos].tileOffsetx=tile.drawingOffsetx; // Where in the tileset the tile is
        Level.currentLevel[arrayPos].tileOffsety=tile.drawingOffsety;

			}
		}

    }

  }
}
txtFile.send(null);

drawText("Loading enemies...", 10, 40);
mutantSpecs = loadJsonFile('enemies/mutant.json');
loadContent(levelName);
setUpContent();

jukeBox.playCurrentSong();
}

var setUpContent = function() {

	for(var i = 0; i < content.length; i++) {
		switch(content[i].type) {
			case "startPos":
        var offset = 15;
				players[0].x = players[0].oldx = content[i].x - offset;
        players[1].x = players[1].oldx = content[i].x + offset;
				players[0].y = players[1].y = players[0].oldy = players[1].oldy = content[i].y;

			break;
		}
	}
}


var drawLevel = function() {
	//Only loop through tiles that are almost in the screen
	var startx=Math.floor(-Viewport.x/Level.tileSize)-1;
	var starty=Math.floor(-Viewport.y/Level.tileSize)-1;
	if(startx<0)
		startx=0;
	if(starty<0)
		starty=0;
	var endx=startx+Viewport.width/Level.tileSize+2;
	var endy=starty+Viewport.height/Level.tileSize+2;



	if(endx>Level.width)
		endx=Level.width;
	if(endy>Level.height)
		endy=Level.height;


	for(var y=starty;y<endy;y++) {
		for(var x=startx;x<endx;x++) {
			var posx = Math.round(Viewport.x+x*Level.tileSize);
			var posy = Math.round(Viewport.y+y*Level.tileSize);

      var isAirTile = Level.currentLevel[x+y*Level.width].type==="."
			if(!isAirTile) {
				ctx.drawImage(tileset,Level.currentLevel[x+y*Level.width].tileOffsetx,Level.currentLevel[x+y*Level.width].tileOffsety, Level.tileSize,
					Level.tileSize,posx,posy, Level.tileSize, Level.tileSize);
			}

		}
	}

  for(var i = 0; i < particles.length; i++) {
    if(!particles[i].shouldBeDeleted) {
      particles[i].render(ctx);
    }
  }
}

var drawText = function(textToDraw, x, y) {
  ctx.fillStyle    = '#F00';
  ctx.font         = '10px Verdana';
  ctx.textBaseline = 'Top';
  ctx.fillText  (textToDraw, x, y);
}

var drawAllText = function() {
	  ctx.fillStyle    = '#FFF';
    ctx.font         = '10px Verdana';
    ctx.textBaseline = 'Top';
    ctx.textAlign = 'left';
    ctx.fillText  ("Score: " + score, 4,20);

    if(outOfBoundsTimer >= 3 && numFramesSinceStart > 10) {
      var fadeOutFactor = outOfBoundsTimer/100;
      ctx.fillStyle    = 'rgba(255,255,255,' + fadeOutFactor + ')';
      ctx.font         = '40px Verdana';
      ctx.textBaseline = 'Top';
      ctx.textAlign = 'center';
      ctx.fillText  ("Please get back together.", 320,100);
      outOfBoundsTimer-=2;
    }

    if(debug===1) {
      var particlesThatShouldBeDeleted = 0;
      for(var i = 0; i < particles.length; i++){
        if(particles[i].shouldBeDeleted) particlesThatShouldBeDeleted++;
      }
      ctx.fillText  ("particles: " + particles.length, 4,60);
      ctx.fillText  ("particlesThatShouldBeDeleted: " + particlesThatShouldBeDeleted, 4,75);
      ctx.fillText  ("numFramesSinceStart: " + numFramesSinceStart, 4,90);
      ctx.fillText  ("Player 1 coordinates: " + players[0].x + " - " + players[0].y, 4,110);
    }
	ctx.strokeStyle = "black";
	ctx.strokeRect(Viewport.width/2-51,15,102,10);
	if(players[0].dead==0) {
		ctx.fillStyle = "rgb(50,129,28)";
    var totalHealth = (players[0].hp + players[1].hp) / 2;
		ctx.fillRect (Viewport.width/2-50,16,Math.round(totalHealth),8);
	}

}

var GameLoop = function(){
  numFramesSinceStart++;
	clear();
  var totalHealth = (players[0].hp + players[1].hp) / 2;
  players[0].hp = players[1].hp = totalHealth;
	if(totalHealth<1) {
		players[0].hp=0;
    players[1].hp=0;
		score=lastScore;
		loadLevel(levelNow);

		init();
	}
	if(players[0].dead==0) {
		checkKeys(1);

    playerIsOutOfBounds = false;
		updatePlayer(0);
		updatePlayer(1);
		render();
	}

	updateEnemies();
  updateParticles();
  renderEnemies();
	drawLevel();
  if(numFramesSinceStart%200 === 0) {
    particleCleaner.cleanupBlood(particles);
  } else if(numFramesSinceStart%100 === 0) {

    for(var i = 0; i < particles.length; i++) {
      if(particles[i].shouldBeDeleted) {
        particles.splice(i,1);
      }
    }
  }


  var arrayPos1 = Level.getBlockAt(players[0].x + players[0].width/2, players[0].y + players[0].height/2);
  var arrayPos2 = Level.getBlockAt(players[1].x + players[1].width/2, players[1].y + players[1].height/2);

	if(arrayPos1.type=="k" || arrayPos2.type=="k") {
			levelNow++;
			lastScore=score;
			loadLevel(levelNow);

			init();
	}
	drawAllText();
	gLoop = setTimeout(GameLoop, 1000 / 50);
}

var stars = [];
for(var i = 0; i < 300; i++) {
  var randomAngle = Math.random()*360;
  var xadd = Math.cos(randomAngle);
  var yadd = Math.sin(randomAngle);
  var startx = Viewport.width*Math.random();
  var starty = Viewport.height*Math.random();
  stars.push(new Particle(320, 100, xadd*5*Math.random(), yadd*5*Math.random(), logoImage));
}

var IntroScreen = function() {
    numFramesSinceStart++;
    clearBlack();
    if(!jukeBox.isSongReady()) {
        ctx.fillStyle    = '#F00';
        ctx.font         = '10px Verdana';
        ctx.textAlign = 'center';
        ctx.fillText  ("Loading...", 320,100);
    }
    else {

      ctx.drawImage(logoImage,220,40);

      ctx.fillStyle    = '#FFF';
      for(var i = 0; i < stars.length; i++) {
        stars[i].x+=stars[i].xSpeed;
        stars[i].y+=stars[i].ySpeed;
        var starIsOutsideOfScreen = stars[i].x < 0
        || stars[i].y < 0
        || stars[i].x > Viewport.width
        || stars[i].y > Viewport.height;
        if(starIsOutsideOfScreen) {
          stars[i].x = 320;
          stars[i].y = 100;
        }
        ctx.fillRect(Math.round(stars[i].x),Math.round(stars[i].y), 2, 2 );
      }
      ctx.fillStyle    = '#F00';
      ctx.font         = '10px Verdana';
      ctx.textAlign = 'center';
      if(Math.abs(Math.sin(numFramesSinceStart/35))<0.9) {
        ctx.fillText  ("Press SPACE to play", 320,200);
      }

      ctx.fillText  ("Player 1(Omar): Arrow keys         Player 2(Cedric): WASD", 320,260);

      ctx.drawImage(players[0].image,0,0,20,30,240,220, players[0].width, players[0].height);
      ctx.drawImage(players[1].image,0,0,20,30,380,220, players[1].width, players[1].height);

      if(32 in keysDown) {
        stars = null;
        loadLevel(levelNow);
        GameLoop();
      }

    }
    gLoop = setTimeout(IntroScreen, 1000 / 50);
}

init();
jukeBox.selectSong(0);
jukeBox.playCurrentSong();

IntroScreen();


</script>
</body>
</html>
